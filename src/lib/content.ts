import { cache } from 'react'
// These are generated by Velite: .velite/index.js
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { projects as allProjects, essays as allEssays } from '../../.velite'

export type Section = 'projects' | 'essays' | 'all'

export type Post = {
  section: 'projects' | 'essays'
  title: string
  slug: string
  date: string
  updated?: string
  summary: string
  tags: string[]
  headerImage?: string
  url: string
  published: boolean
  canonicalUrl?: string
}

function normalize(p: any, section: 'projects' | 'essays') {
  return {
    section,
    title: p.title as string,
    slug: p.slug as string,
    date: new Date(p.date).toISOString(),
    updated: p.updated ? new Date(p.updated).toISOString() : undefined,
    summary: p.summary as string,
    tags: (p.tags || []) as string[],
    headerImage: p.headerImage as string | undefined,
    url: p.url as string,
    published: p.published !== false,
    canonicalUrl: p.canonicalUrl as string | undefined,
  }
}

export function getWithContent(section: 'projects' | 'essays', slug: string) {
  const src = section === 'projects' ? (allProjects as any[]) : (allEssays as any[])
  const found = src.find(p => (p.slug || p._meta?.filename)?.toString() === slug)
  if (!found) return null
  return { ...normalize(found, section), content: (found as any).content as string }
}

export const getAllProjects = cache(({ offset = 0, limit = 10 }: { offset?: number; limit?: number } = {}) => {
  const items = (allProjects as any[]).filter(p => p.published !== false).map(p => normalize(p, 'projects'))
  const sorted = items.sort((a, b) => +new Date(b.date) - +new Date(a.date))
  return sorted.slice(offset, offset + limit)
})

export const getAllEssays = cache(({ offset = 0, limit = 10 }: { offset?: number; limit?: number } = {}) => {
  const items = (allEssays as any[]).filter(p => p.published !== false).map(p => normalize(p, 'essays'))
  const sorted = items.sort((a, b) => +new Date(b.date) - +new Date(a.date))
  return sorted.slice(offset, offset + limit)
})

export const getAllPosts = cache(({ offset = 0, limit = 10 }: { offset?: number; limit?: number } = {}) => {
  const items = [
    ...(allProjects as any[]).filter(p => p.published !== false).map(p => normalize(p, 'projects')),
    ...(allEssays as any[]).filter(p => p.published !== false).map(p => normalize(p, 'essays')),
  ]
  const sorted = items.sort((a, b) => +new Date(b.date) - +new Date(a.date))
  return sorted.slice(offset, offset + limit)
})

export const getBySlug = cache((section: 'projects' | 'essays', slug: string) => {
  const src = section === 'projects' ? (allProjects as any[]) : (allEssays as any[])
  const found = src.find(p => (p.slug || p._meta?.filename)?.toString() === slug)
  return found ? normalize(found, section) : null
})

export const getPrevNext = cache((section: 'projects' | 'essays', slug: string) => {
  const src = section === 'projects' ? (allProjects as any[]) : (allEssays as any[])
  const items = src.filter(p => p.published !== false).map(p => normalize(p, section))
  const sorted = items.sort((a, b) => +new Date(b.date) - +new Date(a.date))
  const idx = sorted.findIndex(p => p.slug === slug)
  return { prev: sorted[idx + 1] || null, next: sorted[idx - 1] || null }
})

export function filterByTag(tag: string, { offset = 0, limit = 10 }: { offset?: number; limit?: number } = {}) {
  const items = [
    ...(allProjects as any[]).filter(p => p.published !== false).map(p => normalize(p, 'projects')),
    ...(allEssays as any[]).filter(p => p.published !== false).map(p => normalize(p, 'essays')),
  ].filter(p => p.tags.includes(tag))
  const sorted = items.sort((a, b) => +new Date(b.date) - +new Date(a.date))
  return sorted.slice(offset, offset + limit)
}

export function getAllTags() {
  const set = new Set<string>()
  ;[(allProjects as any[]), (allEssays as any[])].forEach(arr => arr.forEach((p: any) => (p.tags || []).forEach((t: string) => set.add(t))))
  return [...set].sort()
}

export function getAllPostsFull() {
  const items = [
    ...(allProjects as any[]).filter(p => p.published !== false).map(p => normalize(p, 'projects')),
    ...(allEssays as any[]).filter(p => p.published !== false).map(p => normalize(p, 'essays')),
  ]
  return items.sort((a, b) => +new Date(b.date) - +new Date(a.date))
}

export function getAllBySection(section: 'projects' | 'essays') {
  const src = section === 'projects' ? (allProjects as any[]) : (allEssays as any[])
  const items = src.filter(p => p.published !== false).map(p => normalize(p, section))
  return items.sort((a, b) => +new Date(b.date) - +new Date(a.date))
}
